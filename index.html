<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记录生活点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://github.com/tearfive/tearfive.github.io/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="记录生活点滴">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的博客">
<meta name="twitter:description" content="记录生活点滴">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/tearfive/tearfive.github.io/"/>





  <title>我的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一天进步一点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/tearfive/tearfive.github.io/2017/01/12/日志logback配置解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tearfive">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/12/日志logback配置解析/" itemprop="url">日志logback配置解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-12T10:41:43+08:00">
                2017-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Spring Boot在所有内部日志中使用<a href="http://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">Commons Logging</a>，但是默认配置也提供了对常用日志的支持，如：<a href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html" target="_blank" rel="noopener">Java Util Logging</a>，<a href="http://logging.apache.org/log4j/" target="_blank" rel="noopener">Log4J</a>, <a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2</a>和<a href="http://logback.qos.ch/" target="_blank" rel="noopener">Logback</a>。每种Logger都可以通过配置使用控制台或者文件输出日志内容。</p>
<h1 id="默认日志Logback"><a href="#默认日志Logback" class="headerlink" title="默认日志Logback"></a>默认日志Logback</h1><p><a href="http://www.slf4j.org/" target="_blank" rel="noopener">SLF4J</a>——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。</p>
<p><a href="https://logback.qos.ch/" target="_blank" rel="noopener">Logback</a>是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。</p>
<p>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p>
<p><img src="img\sringboot7-1.png" alt=""></p>
<p>从上图可以看到，日志输出内容元素具体如下：</p>
<blockquote>
<p>时间日期：精确到毫秒<br>日志级别：ERROR, WARN, INFO, DEBUG or TRACE<br>进程ID<br>分隔符：— 标识实际日志的开始<br>线程名：方括号括起来（可能会截断控制台输出）<br>Logger名：通常使用源代码的类名<br>日志内容</p>
</blockquote>
<h3 id="添加日志依赖"><a href="#添加日志依赖" class="headerlink" title="添加日志依赖"></a>添加日志依赖</h3><p>假如maven依赖中添加了spring-boot-starter-logging：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。</p>
<p>但是呢，实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。而博主这次项目的例子是基于上一篇的，工程中有用到了Thymeleaf，而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>具体可以看该图</p>
<p><img src="img\sringboot7-1.png" alt=""></p>
<h3 id="默认配置属性支持"><a href="#默认配置属性支持" class="headerlink" title="默认配置属性支持"></a>默认配置属性支持</h3><p>Spring Boot为我们提供了很多默认的日志配置，所以，只要将spring-boot-starter-logging作为依赖加入到当前应用的classpath，则“开箱即用”。<br>下面介绍几种在application.properties就可以配置的日志相关属性。</p>
<h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。<br>Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可：</p>
<p>在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug<br>在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</p>
<h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p>
<blockquote>
<p>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log<br>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</p>
</blockquote>
<p>如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。<br>如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log</p>
<h4 id="注：二者不能同时使用，如若同时使用，则只有logging-file生效"><a href="#注：二者不能同时使用，如若同时使用，则只有logging-file生效" class="headerlink" title="注：二者不能同时使用，如若同时使用，则只有logging.file生效"></a>注：二者不能同时使用，如若同时使用，则只有logging.file生效</h4><p><strong>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p>
<h3 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h3><p>所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中）<br>格式为：’logging.level.* = LEVEL’</p>
<blockquote>
<p>logging.level：日志级别控制前缀，*为包名或Logger名<br>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</p>
</blockquote>
<p>举例：</p>
<blockquote>
<p>logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出<br>logging.level.root=WARN：root日志以WARN级别输出</p>
</blockquote>
<h3 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h3><p>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p>
<p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<blockquote>
<p>Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy<br>Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml<br>Log4j2：log4j2-spring.xml, log4j2.xml<br>JDK (Java Util Logging)：logging.properties</p>
</blockquote>
<p><strong>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。</strong></p>
<p>上面是默认的命名规则，并且放在src/main/resources下面即可。</p>
<p>如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以在application.properties配置文件里面通过logging.config属性指定自定义的名字：</p>
<pre><code>logging.config=classpath:logging-config.xml
</code></pre><p>虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日<br>志配置，这个功能会很有用。</p>
<p>下面我们来看看一个普通的logback-spring.xml例子</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;
    &lt;contextName&gt;logback&lt;/contextName&gt;
    &lt;property name=&quot;log.path&quot; value=&quot;/Users/tengjun/Documents/log&quot; /&gt;
    &lt;!--输出到控制台--&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
       &lt;!-- &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
        &lt;/filter&gt;--&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;!--输出到文件--&gt;
    &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${log.path}/logback.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot; /&gt;
        &lt;appender-ref ref=&quot;file&quot; /&gt;
    &lt;/root&gt;

    &lt;!-- logback为java中的包 --&gt;
    &lt;logger name=&quot;com.dudu.controller&quot;/&gt;
    &lt;!--logback.LogbackDemo：类的全路径 --&gt;
    &lt;logger name=&quot;com.dudu.controller.LearnController&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre><h4 id="根节点-lt-configuration-gt-包含的属性"><a href="#根节点-lt-configuration-gt-包含的属性" class="headerlink" title="根节点&lt;configuration&gt;包含的属性"></a>根节点&lt;configuration&gt;包含的属性</h4><hr>
<blockquote>
<p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。<br>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p>
</blockquote>
<p>根节点&lt;configuration&gt;的子节点：<br>&lt;configuration&gt;下面一共有2个属性，3个子节点，分别是：</p>
<h4 id="属性一：设置上下文名称-lt-contextName-gt"><a href="#属性一：设置上下文名称-lt-contextName-gt" class="headerlink" title="属性一：设置上下文名称&lt;contextName&gt;"></a>属性一：设置上下文名称&lt;contextName&gt;</h4><hr>
<p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称。</p>
<pre><code>&lt;contextName&gt;logback&lt;/contextName&gt;
</code></pre><h4 id="属性二：设置变量-lt-property-gt"><a href="#属性二：设置变量-lt-property-gt" class="headerlink" title="属性二：设置变量&lt;property&gt;"></a>属性二：设置变量&lt;property&gt;</h4><hr>
<p>用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。</p>
<pre><code>&lt;property name=&quot;log.path&quot; value=&quot;/Users/tengjun/Documents/log&quot; /&gt;
</code></pre><h4 id="子节点一-lt-appender-gt"><a href="#子节点一-lt-appender-gt" class="headerlink" title="子节点一&lt;appender&gt;"></a>子节点一&lt;appender&gt;</h4><p>appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。</p>
<h5 id="控制台输出ConsoleAppender："><a href="#控制台输出ConsoleAppender：" class="headerlink" title="控制台输出ConsoleAppender："></a>控制台输出ConsoleAppender：</h5><pre><code>&lt;!--输出到控制台--&gt;
&lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
        &lt;level&gt;ERROR&lt;/level&gt;
    &lt;/filter&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre><p>&lt;encoder&gt;表示对日志进行编码：</p>
<blockquote>
<p>%d{HH: mm:ss.SSS}——日志输出时间<br>%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用<br>%-5level——日志级别，并且使用5个字符靠左对齐<br>%logger{36}——日志输出者的名字<br>%msg——日志消息<br>%n——平台的换行符</p>
</blockquote>
<p>ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~</p>
<h5 id="输出到文件RollingFileAppender"><a href="#输出到文件RollingFileAppender" class="headerlink" title="输出到文件RollingFileAppender"></a>输出到文件RollingFileAppender</h5><p>另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志：</p>
<pre><code>&lt;!--输出到文件--&gt;
&lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
        &lt;fileNamePattern&gt;${log.path}/logback.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
        &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;
    &lt;/rollingPolicy&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre><p>其中重要的是rollingPolicy的定义，上例中<filenamepattern>${log.path}/logback.%d{yyyy-MM-dd}.log</filenamepattern>定义了日志的切分方式——把每一天的日志归档到一个文件中，<maxhistory>30</maxhistory>表示只保留最近30天的日志，以防止日志填满整个磁盘空间。同理，可以使用%d{yyyy-MM-dd_HH-mm}来定义精确到分的日志切分方式。<totalsizecap>1GB</totalsizecap>用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。</p>
<p>补:如果你想把日志直接放到当前项目下，把${log.path}/去掉即可。</p>
<h4 id="子节点二-lt-root-gt"><a href="#子节点二-lt-root-gt" class="headerlink" title="子节点二&lt;root&gt;"></a>子节点二&lt;root&gt;</h4><p>root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性。</p>
<blockquote>
<p>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。<br>默认是DEBUG。</p>
</blockquote>
<p>可以包含零个或多个元素，标识这个appender将会添加到这个logger。</p>
<pre><code>&lt;root level=&quot;debug&quot;&gt;
    &lt;appender-ref ref=&quot;console&quot; /&gt;
    &lt;appender-ref ref=&quot;file&quot; /&gt;
&lt;/root&gt;
</code></pre><h4 id="子节点三-lt-logger-gt"><a href="#子节点三-lt-logger-gt" class="headerlink" title="子节点三&lt;logger&gt;"></a>子节点三&lt;logger&gt;</h4><p>&lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性。</p>
<blockquote>
<p>name:用来指定受此logger约束的某一个包或者具体的某一个类。<br>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前logger将会继承上级的级别。<br>addtivity:是否向上级logger传递打印信息。默认是true。</p>
</blockquote>
<p>logger在实际使用的时候有两种情况<br>先来看一看代码中如何使用</p>
<pre><code>package com.dudu.controller;
@Controller
public class LearnController {
    private Logger logger = LoggerFactory.getLogger(this.getClass());
    @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)
    @ResponseBody
    public Map&lt;String,Object&gt; login(HttpServletRequest request, HttpServletResponse response){
        //日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。
        logger.trace(&quot;日志输出 trace&quot;);
        logger.debug(&quot;日志输出 debug&quot;);
        logger.info(&quot;日志输出 info&quot;);
        logger.warn(&quot;日志输出 warn&quot;);
        logger.error(&quot;日志输出 error&quot;);
        Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;();
        String userName=request.getParameter(&quot;userName&quot;);
        String password=request.getParameter(&quot;password&quot;);
        if(!userName.equals(&quot;&quot;) &amp;&amp; password!=&quot;&quot;){
            User user =new User(userName,password);
            request.getSession().setAttribute(&quot;user&quot;,user);
            map.put(&quot;result&quot;,&quot;1&quot;);
        }else{
            map.put(&quot;result&quot;,&quot;0&quot;);
        }
        return map;
    }
}
</code></pre><p>这是一个登录的判断的方法，我们引入日志，并且打印不同级别的日志，然后根据logback-spring.xml中的配置来看看打印了哪几种级别日志。</p>
<h5 id="第一种：带有logger的配置，不指定级别，不指定appender"><a href="#第一种：带有logger的配置，不指定级别，不指定appender" class="headerlink" title="第一种：带有logger的配置，不指定级别，不指定appender"></a>第一种：带有logger的配置，不指定级别，不指定appender</h5><pre><code>&lt;logger name=&quot;com.dudu.controller&quot;/&gt;
</code></pre><p>&lt;logger name=”com.dudu.controller” /&gt;将控制controller包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“info”；<br>没有设置addtivity，默认为true，将此logger的打印信息向上级传递；<br>没有设置appender，此logger本身不打印任何信息。<br>&lt;root level=”info”&gt;将root的打印级别设置为“info”，指定了名字为“console”的appender。</p>
<p>当执行com.dudu.controller.LearnController类的login方法时，LearnController 在包com.dudu.controller中，所以首先执行<logger name="com.dudu.controller">，将级别为“info”及大于“info”的日志信息传递给root，本身并不打印；<br>root接到下级传递的信息，交给已经配置好的名为“console”的appender处理，“console”appender将信息打印到控制台；</logger></p>
<p>打印结果如下：</p>
<pre><code>16:00:17.407 logback [http-nio-8080-exec-8] INFO  com.dudu.controller.LearnController - 日志输出 info
16:00:17.408 logback [http-nio-8080-exec-8] WARN  com.dudu.controller.LearnController - 日志输出 warn
16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.dudu.controller.LearnController - 日志输出 error
</code></pre><p>第二种：带有多个logger的配置，指定级别，指定appender</p>
<pre><code>&lt;!--logback.LogbackDemo：类的全路径 --&gt;
&lt;logger name=&quot;com.dudu.controller.LearnController&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;
    &lt;appender-ref ref=&quot;console&quot;/&gt;
&lt;/logger&gt;
</code></pre><p>控制com.dudu.controller.LearnController类的日志打印，打印级别为“WARN”;<br>additivity属性为false，表示此logger的打印信息不再向上级传递;<br>指定了名字为“console”的appender;</p>
<p>这时候执行com.dudu.controller.LearnController类的login方法时，先执行<logger name="com.dudu.controller.LearnController" level="WARN" additivity="false">,<br>将级别为“WARN”及大于“WARN”的日志信息交给此logger指定的名为“console”的appender处理，在控制台中打出日志，不再向上级root传递打印信息。<br>打印结果如下：</logger></p>
<pre><code>16:00:17.408 logback [http-nio-8080-exec-8] WARN  com.dudu.controller.LearnController - 日志输出 warn
16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.dudu.controller.LearnController - 日志输出 error
</code></pre><p>当然如果你把additivity=”false”改成additivity=”true”的话，就会打印两次，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。</p>
<p>注：使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</p>
<p>第一种把&lt;root level=”info”&gt;改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息。<br>第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：</root></p>
<pre><code>&lt;logger name=&quot;com.dudu.dao&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
    &lt;appender-ref ref=&quot;console&quot; /&gt;
&lt;/logger&gt;
</code></pre><h3 id="多环境日志输出"><a href="#多环境日志输出" class="headerlink" title="多环境日志输出"></a>多环境日志输出</h3><p>据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：</p>
<pre><code>文件名称不是logback.xml，想使用spring扩展profile支持，要以logback-spring.xml命名
</code></pre><hr>
<pre><code>&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;
&lt;springProfile name=&quot;test,dev&quot;&gt;
    &lt;logger name=&quot;com.dudu.controller&quot; level=&quot;info&quot; /&gt;
&lt;/springProfile&gt;
&lt;!-- 生产环境. --&gt;
&lt;springProfile name=&quot;prod&quot;&gt;
    &lt;logger name=&quot;com.dudu.controller&quot; level=&quot;ERROR&quot; /&gt;
&lt;/springProfile&gt;
</code></pre><p>可以启动服务的时候指定 profile （如不指定使用默认），如指定prod 的方式为：<br>java -jar xxx.jar –spring.profiles.active=prod</p>
<p>总结<br>到此为止终于介绍完日志框架了，平时使用的时候推荐用自定义logback-spring.xml来配置，代码中使用日志也很简单，类里面添加private Logger logger = LoggerFactory.getLogger(this.getClass());即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/tearfive/tearfive.github.io/2016/08/01/自定义@CurrentUser获取当前登录用户/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tearfive">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/01/自定义@CurrentUser获取当前登录用户/" itemprop="url">自定义@CurrentUser获取当前登录用户</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-01T20:23:43+08:00">
                2016-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="定义-CurrenUser注解"><a href="#定义-CurrenUser注解" class="headerlink" title="定义 @CurrenUser注解"></a>定义 @CurrenUser注解</h1><pre><code>/**
 * 在Controller的方法参数中使用此注解，该方法在映射时会注入当前登录的User对象
 */
@Target(ElementType.PARAMETER)//可用在方法的参数上
@Retention(RetentionPolicy.RUNTIME)//运行时有效
public @interface CurrentUser {
}
</code></pre><h1 id="添加测试方法"><a href="#添加测试方法" class="headerlink" title="添加测试方法"></a>添加测试方法</h1><p>在 userApi.java 中添加临时测试用的，测试完记得删掉。</p>
<pre><code>@GetMapping(&quot;/test&quot;)
@LoginRequired
public Object testCurrentUser(@CurrentUser User user) {
    return user;
}
</code></pre><p>不要忘了添加 @LoginRequired 这个注解（上节添加的），要获取当前登录用户嘛，肯定得要求用户登录。重启项目访问 /api/user/test测试下。</p>
<p><img src="img\3907956-5d831a4f4501a5b8.png" alt=""></p>
<p>记得填写 token（访问登录接口获取）。全是null，很遗憾现在还不能返回我们想要的用户信息。</p>
<h1 id="添加参数解析器"><a href="#添加参数解析器" class="headerlink" title="添加参数解析器"></a>添加参数解析器</h1><p>要想 @CurrentUser 起作用，需要编写一个配套解析器，做法是实现 spring 提供的 HandlerMethodArgumentResolver 接口。<br>新增 CurrentUserMethodArgumentResolver.java</p>
<pre><code>/**
 *  增加方法注入，将含有 @CurrentUser 注解的方法参数注入当前登录用户
 */
public class CurrentUserMethodArgumentResolver implements HandlerMethodArgumentResolver {
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().isAssignableFrom(User.class)
                &amp;&amp; parameter.hasParameterAnnotation(CurrentUser.class);
    }
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        User user = (User) webRequest.getAttribute(&quot;currentUser&quot;, RequestAttributes.SCOPE_REQUEST);
        if (user != null) {
            return user;
        }
        throw new MissingServletRequestPartException(&quot;currentUser&quot;);
    }
}
</code></pre><p>User user = (User) webRequest.getAttribute(“currentUser”, RequestAttributes.SCOPE_REQUEST) 这一句是从 request 作用域中取出名为 currentUser 的属性。currentUser 是什么呢？在上节编写的登录拦截器中，最后有这么一句 request.setAttribute(“currentUser”, user)，所以 currentUser 是 token 验证通过之后查询到的当前用户。</p>
<h1 id="配置参数解析器"><a href="#配置参数解析器" class="headerlink" title="配置参数解析器"></a>配置参数解析器</h1><p>在 WebMvcConfigurer.java 中 Override addArgumentResolvers 方法</p>
<pre><code>@Override
public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
    argumentResolvers.add(currentUserMethodArgumentResolver());
    super.addArgumentResolvers(argumentResolvers);
}
@Bean
public CurrentUserMethodArgumentResolver currentUserMethodArgumentResolver() {
    return new CurrentUserMethodArgumentResolver();
}
</code></pre><h1 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h1><p>我是用 “张三” 这个用户登录获取的 token，正确地返回了张三的信息。</p>
<p><img src="img\3907956-1dda70c8a9342adf.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/tearfive/tearfive.github.io/2016/01/11/使用JWT保护你的spring boot应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tearfive">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/11/使用JWT保护你的spring boot应用/" itemprop="url">使用JWT保护你的springboot应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-11T17:16:47+08:00">
                2016-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用JWT保护你的Spring-Boot应用"><a href="#使用JWT保护你的Spring-Boot应用" class="headerlink" title="使用JWT保护你的Spring Boot应用"></a>使用JWT保护你的Spring Boot应用</h1><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>有了Spring Boot这样的神器，可以很简单的使用强大的Spring框架。你需要关心的事儿只是创建应用，不必再配置了，“Just run!”，这可是Josh Long每次演讲必说的，他的另一句必须说的就是“make jar not war”，这意味着，不用太关心是Tomcat还是Jetty或者Undertow了。专心解决逻辑问题，这当然是个好事儿，部署简单了很多。</p>
<h2 id="创建Spring-Boot应用"><a href="#创建Spring-Boot应用" class="headerlink" title="创建Spring Boot应用"></a>创建Spring Boot应用</h2><p>有很多方法去创建Spring Boot项目，官方也推荐用：</p>
<p><a href="http://start.spring.io/" target="_blank" rel="noopener">Spring Boot在线项目创建</a><br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/cli-using-the-cli.html" target="_blank" rel="noopener">CLI 工具</a></p>
<p>start.spring.io可以方便选择你要用的组件，命令行工具当然也可以。目前Spring Boot已经到了1.53，我是懒得去更新依赖，继续用1.52版本。虽然阿里也有了中央库的国内版本不知道是否稳定。如果你感兴趣，可以自己尝试下。你可以选Maven或者Gradle成为你项目的构建工具，Gradle优雅一些，使用了Groovy语言进行描述。</p>
<p>打开start.spring.io，创建的项目只需要一个Dependency，也就是Web，然后下载项目，用IntellJ IDEA打开。我的Java版本是1.7。</p>
<p>这里看下整个项目的pom.xml文件中的依赖部分:</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>所有Spring Boot相关的依赖都是以starter形式出现，这样你无需关心版本和相关的依赖，所以这样大大简化了开发过程。</p>
<p>当你在pom文件中集成了spring-boot-maven-plugin插件后你可以使用Maven相关的命令来run你的应用。例如mvn spring-boot:run，这样会启动一个嵌入式的Tomcat，并运行在8080端口，直接访问你当然会获得一个Whitelabel Error Page，这说明Tomcat已经启动了。</p>
<h2 id="创建一个Web-应用"><a href="#创建一个Web-应用" class="headerlink" title="创建一个Web 应用"></a>创建一个Web 应用</h2><p>这还是一篇关于Web安全的文章，但是也得先有个简单的HTTP请求响应。我们先弄一个可以返回JSON的Controller。修改程序的入口文件：</p>
<pre><code>@SpringBootApplication
@RestController
@EnableAutoConfiguration
public class DemoApplication {
    // main函数，Spring Boot程序入口
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
    // 根目录映射 Get访问方式 直接返回一个字符串
    @RequestMapping(&quot;/&quot;)
    Map&lt;String, String&gt; hello() {
      // 返回map会变成JSON key value方式
      Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();
      map.put(&quot;content&quot;, &quot;hello freewolf~&quot;);
      return map;
    }
}
</code></pre><p>这里我尽量的写清楚，让不了解Spring Security的人通过这个例子可以了解这个东西，很多人都觉得它很复杂，而投向了Apache Shiro，其实这个并不难懂。知道主要的处理流程，和这个流程中哪些类都起了哪些作用就好了。</p>
<p>Spring Boot对于开发人员最大的好处在于可以对Spring应用进行自动配置。Spring Boot会根据应用中声明的第三方依赖来自动配置Spring框架，而不需要进行显式的声明。Spring Boot推荐采用基于Java注解的配置方式，而不是传统的XML。只需要在主配置 Java 类上添加@EnableAutoConfiguration注解就可以启用自动配置。Spring Boot的自动配置功能是没有侵入性的，只是作为一种基本的默认实现。</p>
<p>这个入口类我们添加@RestController和@EnableAutoConfiguration两个注解。<br>@RestController注解相当于@ResponseBody和@Controller合在一起的作用。</p>
<p>run整个项目。访问<a href="http://localhost:8080/就能看到这个JSON的输出。使用Chrome浏览器可以装JSON" target="_blank" rel="noopener">http://localhost:8080/就能看到这个JSON的输出。使用Chrome浏览器可以装JSON</a> Formatter这个插件，显示更PL一些。</p>
<pre><code>{
  &quot;content&quot;: &quot;hello freewolf~&quot;
}
</code></pre><p>为了显示统一的JSON返回，这里建立一个JSONResult类进行，简单的处理。首先修改pom.xml，加入org.json相关依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.json&lt;/groupId&gt;
    &lt;artifactId&gt;json&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后在我们的代码中加入一个新的类，里面只有一个结果集处理方法，因为只是个Demo，所有这里都放在一个文件中。这个类只是让返回的JSON结果变为三部分：</p>
<pre><code>status - 返回状态码 0 代表正常返回，其他都是错误
message - 一般显示错误信息
result - 结果集
</code></pre><hr>
<pre><code>class JSONResult{
    public static String fillResultString(Integer status, String message, Object result){
        JSONObject jsonObject = new JSONObject(){{
	            put("status", status);
	            put("message", message);
	            put("result", result);
	        }};
        return jsonObject.toString();
    }
}
</code></pre><p>然后我们引入一个新的@RestController并返回一些简单的结果，后面我们将对这些内容进行访问控制，这里用到了上面的结果集处理类。这里多放两个方法，后面我们来测试权限和角色的验证用。</p>
<pre><code>@RestController
class UserController {
    // 路由映射到/users
    @RequestMapping(value = &quot;/users&quot;, produces=&quot;application/json;charset=UTF-8&quot;)
    public String usersList() {
        ArrayList&lt;String&gt; users =  new ArrayList&lt;String&gt;(){{
	            add("freewolf");
	            add("tom");
	            add("jerry");
	        }};
        return JSONResult.fillResultString(0, &quot;&quot;, users);
    }
    @RequestMapping(value = &quot;/hello&quot;, produces=&quot;application/json;charset=UTF-8&quot;)
    public String hello() {
        ArrayList&lt;String&gt; users =  new ArrayList&lt;String&gt;(){{ add("hello"); }};
        return JSONResult.fillResultString(0, &quot;&quot;, users);
    }
    @RequestMapping(value = &quot;/world&quot;, produces=&quot;application/json;charset=UTF-8&quot;)
    public String world() {
        ArrayList&lt;String&gt; users =  new ArrayList&lt;String&gt;(){{ add("world"); }};
        return JSONResult.fillResultString(0, &quot;&quot;, users);
    }
}
</code></pre><p>重新run这个文件，访问<a href="http://localhost:8080/users就看到了下面的结果" target="_blank" rel="noopener">http://localhost:8080/users就看到了下面的结果</a>:</p>
<pre><code>{
  &quot;result&quot;: [
    &quot;freewolf&quot;,
    &quot;tom&quot;,
    &quot;jerry&quot;
  ],
  &quot;message&quot;: &quot;&quot;,
  &quot;status&quot;: 0
}
</code></pre><p>如果你细心，你会发现这里的JSON返回时，Chrome的格式化插件好像并没有识别？这是为什么呢？我们借助curl分别看一下我们写的两个方法的Header信息.</p>
<pre><code>curl -I http://127.0.0.1:8080/
curl -I http://127.0.0.1:8080/users
</code></pre><p>可以看到第一个方法hello，由于返回值是Map<string, string="">，Spring已经有相关的机制自动处理成JSON:</string,></p>
<pre><code>Content-Type: application/json;charset=UTF-8
</code></pre><p>第二个方法usersList由于返回时String，由于是@RestControler已经含有了@ResponseBody也就是直接返回内容，并不模板。所以就是：</p>
<pre><code>Content-Type: text/plain;charset=UTF-8
</code></pre><p>那怎么才能让它变成JSON呢，其实也很简单只需要补充一下相关注解：</p>
<pre><code>@RequestMapping(value = &quot;/users&quot;, produces=&quot;application/json;charset=UTF-8&quot;)
</code></pre><p>这样就好了。</p>
<h1 id="使用JWT保护你的Spring-Boot应用-1"><a href="#使用JWT保护你的Spring-Boot应用-1" class="headerlink" title="使用JWT保护你的Spring Boot应用"></a>使用JWT保护你的Spring Boot应用</h1><p>终于我们开始介绍正题，这里我们会对/users进行访问控制，先通过申请一个JWT(JSON Web Token读jot)，然后通过这个访问/users，才能拿到数据。</p>
<p>关于JWT,出门奔向以下内容，这些不在本文讨论范围内:</p>
<p><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC7519</a><br><br><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a></p>
<p>JWT很大程度上还是个新技术，通过使用HMAC(Hash-based Message Authentication Code)计算信息摘要，也可以用RSA公私钥中的私钥进行签名。这个根据业务场景进行选择。</p>
<h2 id="添加Spring-Security"><a href="#添加Spring-Security" class="headerlink" title="添加Spring Security"></a>添加Spring Security</h2><p>根据上文我们说过我们要对/users进行访问控制，让用户在/login进行登录并获得Token。这里我们需要将spring-boot-starter-security加入pom.xml。加入后，我们的Spring Boot项目将需要提供身份验证，相关的pom.xml如下:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>至此我们之前所有的路由都需要身份验证。我们将引入一个安全设置类WebSecurityConfig，这个类需要从WebSecurityConfigurerAdapter类继承。</p>
<pre><code>@Configuration
@EnableWebSecurity
class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    // 设置 HTTP 验证规则
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 关闭csrf验证
        http.csrf().disable()
                // 对请求进行认证
                .authorizeRequests()
                // 所有 / 的所有请求 都放行
                .antMatchers(&quot;/&quot;).permitAll()
                // 所有 /login 的POST请求 都放行
                .antMatchers(HttpMethod.POST, &quot;/login&quot;).permitAll()
                // 权限检查
                .antMatchers(&quot;/hello&quot;).hasAuthority(&quot;AUTH_WRITE&quot;)
                // 角色检查
                .antMatchers(&quot;/world&quot;).hasRole(&quot;ADMIN&quot;)
                // 所有请求需要身份认证
                .anyRequest().authenticated()
            .and()
                // 添加一个过滤器 所有访问 /login 的请求交给 JWTLoginFilter 来处理 这个类处理所有的JWT相关内容
                .addFilterBefore(new JWTLoginFilter(&quot;/login&quot;, authenticationManager()),
                        UsernamePasswordAuthenticationFilter.class)
                // 添加一个过滤器验证其他请求的Token是否合法
                .addFilterBefore(new JWTAuthenticationFilter(),
                        UsernamePasswordAuthenticationFilter.class);
    }
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 使用自定义身份验证组件
        auth.authenticationProvider(new CustomAuthenticationProvider());
    }
}
</code></pre><p>先放两个基本类，一个负责存储用户名密码，另一个是一个权限类型，负责存储权限和角色。</p>
<pre><code>class AccountCredentials {
    private String username;
    private String password;
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
}
class GrantedAuthorityImpl implements GrantedAuthority{
    private String authority;
    public GrantedAuthorityImpl(String authority) {
        this.authority = authority;
    }
    public void setAuthority(String authority) {
        this.authority = authority;
    }
    @Override
    public String getAuthority() {
        return this.authority;
    }
}
</code></pre><p>在上面的安全设置类中，我们设置所有人都能访问/和POST方式访问/login，其他的任何路由都需要进行认证。然后将所有访问/login的请求，都交给JWTLoginFilter过滤器来处理。稍后我们会创建这个过滤器和其他这里需要的JWTAuthenticationFilter和CustomAuthenticationProvider两个类。</p>
<p>先建立一个JWT生成，和验签的类</p>
<pre><code>class TokenAuthenticationService {
    static final long EXPIRATIONTIME = 432_000_000;     // 5天
    static final String SECRET = &quot;P@ssw02d&quot;;            // JWT密码
    static final String TOKEN_PREFIX = &quot;Bearer&quot;;        // Token前缀
    static final String HEADER_STRING = &quot;Authorization&quot;;// 存放Token的Header Key
  // JWT生成方法
    static void addAuthentication(HttpServletResponse response, String username) {
    // 生成JWT
        String JWT = Jwts.builder()
                // 保存权限（角色）
                .claim(&quot;authorities&quot;, &quot;ROLE_ADMIN,AUTH_WRITE&quot;)
                // 用户名写入标题
                .setSubject(username)
                // 有效期设置
                        .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))
                // 签名设置
                        .signWith(SignatureAlgorithm.HS512, SECRET)
                        .compact();
        // 将 JWT 写入 body
        try {
            response.setContentType(&quot;application/json&quot;);
            response.setStatus(HttpServletResponse.SC_OK);
            response.getOutputStream().println(JSONResult.fillResultString(0, &quot;&quot;, JWT));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
  // JWT验证方法
    static Authentication getAuthentication(HttpServletRequest request) {
        // 从Header中拿到token
        String token = request.getHeader(HEADER_STRING);
        if (token != null) {
            // 解析 Token
            Claims claims = Jwts.parser()
                    // 验签
                    .setSigningKey(SECRET)
                    // 去掉 Bearer
                    .parseClaimsJws(token.replace(TOKEN_PREFIX, &quot;&quot;))
                    .getBody();

            // 拿用户名
            String user = claims.getSubject();
            // 得到 权限（角色）
            List&lt;GrantedAuthority&gt; authorities =  AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(&quot;authorities&quot;));
            // 返回验证令牌
            return user != null ?
                    new UsernamePasswordAuthenticationToken(user, null, authorities) :
                    null;
        }
        return null;
    }
}
</code></pre><p>这个类就两个static方法，一个负责生成JWT，一个负责认证JWT最后生成验证令牌。注释已经写得很清楚了，这里不多说了。</p>
<p>下面来看自定义验证组件，这里简单写了，这个类就是提供密码验证功能，在实际使用时换成自己相应的验证逻辑，从数据库中取出、比对、赋予用户相应权限。</p>
<pre><code>// 自定义身份认证验证组件
class CustomAuthenticationProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        // 获取认证的用户名 &amp; 密码
        String name = authentication.getName();
        String password = authentication.getCredentials().toString();
        // 认证逻辑
        if (name.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123456&quot;)) {
            // 这里设置权限和角色
            ArrayList&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
            authorities.add( new GrantedAuthorityImpl(&quot;ROLE_ADMIN&quot;) );
            authorities.add( new GrantedAuthorityImpl(&quot;AUTH_WRITE&quot;) );
            // 生成令牌
            Authentication auth = new UsernamePasswordAuthenticationToken(name, password, authorities);
            return auth;
        }else {
            throw new BadCredentialsException(&quot;密码错误~&quot;);
        }
    }
    // 是否可以提供输入类型的认证服务
    @Override
    public boolean supports(Class&lt;?&gt; authentication) {
        return authentication.equals(UsernamePasswordAuthenticationToken.class);
    }
}
</code></pre><p>下面实现JWTLoginFilter 这个Filter比较简单，除了构造函数需要重写三个方法。</p>
<p>attemptAuthentication - 登录时需要验证时候调用<br><br>successfulAuthentication - 验证成功后调用<br><br>unsuccessfulAuthentication - 验证失败后调用，这里直接灌入500错误返回，由于同一JSON返回，HTTP就都返回200了</p>
<hr>
<pre><code>class JWTLoginFilter extends AbstractAuthenticationProcessingFilter {
    public JWTLoginFilter(String url, AuthenticationManager authManager) {
        super(new AntPathRequestMatcher(url));
        setAuthenticationManager(authManager);
    }
    @Override
    public Authentication attemptAuthentication(
            HttpServletRequest req, HttpServletResponse res)
            throws AuthenticationException, IOException, ServletException {
        // JSON反序列化成 AccountCredentials
        AccountCredentials creds = new ObjectMapper().readValue(req.getInputStream(), AccountCredentials.class);
        // 返回一个验证令牌
        return getAuthenticationManager().authenticate(
                new UsernamePasswordAuthenticationToken(
                        creds.getUsername(),
                        creds.getPassword()
                )
        );
    }
    @Override
    protected void successfulAuthentication(
            HttpServletRequest req,
            HttpServletResponse res, FilterChain chain,
            Authentication auth) throws IOException, ServletException {
        TokenAuthenticationService.addAuthentication(res, auth.getName());
    }
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        response.setContentType(&quot;application/json&quot;);
        response.setStatus(HttpServletResponse.SC_OK);
        response.getOutputStream().println(JSONResult.fillResultString(500, &quot;Internal Server Error!!!&quot;, JSONObject.NULL));
    }
}
</code></pre><p>再完成最后一个类JWTAuthenticationFilter，这也是个拦截器，它拦截所有需要JWT的请求，然后调用TokenAuthenticationService类的静态方法去做JWT验证。</p>
<pre><code>class JWTAuthenticationFilter extends GenericFilterBean {
    @Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain filterChain)
            throws IOException, ServletException {
        Authentication authentication = TokenAuthenticationService
                .getAuthentication((HttpServletRequest)request);
        SecurityContextHolder.getContext()
                .setAuthentication(authentication);
        filterChain.doFilter(request,response);
    }
}
</code></pre><p>现在代码就写完了，整个Spring Security结合JWT基本就差不多了，下面我们来测试下，并说下整体流程。</p>
<p>开始测试，先运行整个项目，这里介绍下过程：</p>
<blockquote>
<p>先程序启动 - main函数<br><br>注册验证组件 - WebSecurityConfig 类 configure(AuthenticationManagerBuilder auth)方法，这里我们注册了自定义验证组件<br><br>设置验证规则 - WebSecurityConfig 类 configure(HttpSecurity http)方法，这里设置了各种路由访问规则<br><br>初始化过滤组件 - JWTLoginFilter 和 JWTAuthenticationFilter 类会初始化<br></p>
</blockquote>
<p>首先测试获取Token，这里使用CURL命令行工具来测试。</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -X POST -d &apos;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;}&apos; 
http://127.0.0.1:8080/login
</code></pre><p>结果：</p>
<pre><code>{
  &quot;result&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfQURNSU4sQVVUSF9XUklURSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNDkzNzgyMjQwfQ.HNfV1CU2CdAnBTH682C5-KOfr2P71xr9PYLaLpDVhOw8KWWSJ0lBo0BCq4LoNwsK_Y3-W3avgbJb0jW9FNYDRQ&quot;,
  &quot;message&quot;: &quot;&quot;,
  &quot;status&quot;: 0
}
</code></pre><p>这里我们得到了相关的JWT，反Base64之后,就是下面的内容，标准JWT。</p>
<pre><code>{&quot;alg&quot;:&quot;HS512&quot;}{&quot;authorities&quot;:&quot;ROLE_ADMIN,AUTH_WRITE&quot;,&quot;sub&quot;:&quot;admin&quot;,&quot;exp&quot;:1493782240}ͽ]BS`pS6~hCVH%
ܬ)֝ଖoE5р
</code></pre><p>整个过程如下：</p>
<blockquote>
<p>拿到传入JSON，解析用户名密码 - JWTLoginFilter 类 attemptAuthentication 方法<br><br>自定义身份认证验证组件，进行身份认证 - CustomAuthenticationProvider 类 authenticate 方法<br><br>验证成功 - JWTLoginFilter 类 successfulAuthentication 方法<br><br>生成JWT - TokenAuthenticationService 类 addAuthentication方法<br></p>
</blockquote>
<p>再测试一个访问资源的：</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfQURNSU4sQVVUSF9XUklURSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNDkzNzgyMjQwfQ.HNfV1CU2CdAnBTH682C5-KOfr2P71xr9PYLaLpDVhOw8KWWSJ0lBo0BCq4LoNwsK_Y3-W3avgbJb0jW9FNYDRQ&quot; 
http://127.0.0.1:8080/users
</code></pre><p>结果：</p>
<pre><code>{
  &quot;result&quot;:[&quot;freewolf&quot;,&quot;tom&quot;,&quot;jerry&quot;],
  &quot;message&quot;:&quot;&quot;,
  &quot;status&quot;:0
}
</code></pre><p>说明我们的Token生效可以正常访问。其他的结果您可以自己去测试。再回到处理流程：</p>
<blockquote>
<p>接到请求进行拦截 - JWTAuthenticationFilter 中的方法<br><br>验证JWT - TokenAuthenticationService 类 getAuthentication 方法<br><br>访问Controller<br></p>
</blockquote>
<p>这样本文的主要流程就结束了，本文主要介绍了，如何用Spring Security结合JWT保护你的Spring Boot应用。如何使用Role和Authority，这里多说一句其实在Spring Security中，对于GrantedAuthority接口实现类来说是不区分是Role还是Authority，二者区别就是如果是hasAuthority判断，就是判断整个字符串，判断hasRole时，系统自动加上ROLE_到判断的Role字符串上，也就是说hasRole(“CREATE”)和hasAuthority(‘ROLE_CREATE’)是相同的。利用这些可以搭建完整的RBAC体系。本文到此，你已经会用了本文介绍的知识点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/tearfive/tearfive.github.io/2015/08/01/Spring Boot_jsp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tearfive">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/01/Spring Boot_jsp/" itemprop="url">Spring Boot 添加JSP支持</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-01T21:19:23+08:00">
                2015-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="创建Maven-web-project"><a href="#创建Maven-web-project" class="headerlink" title="创建Maven web project"></a>创建Maven web project</h4><p>使用Eclipse新建一个Maven Web Project ，项目取名为：spring-boot-jsp</p>
<h4 id="在pom-xml文件添加依赖"><a href="#在pom-xml文件添加依赖" class="headerlink" title="在pom.xml文件添加依赖"></a>在pom.xml文件添加依赖</h4><pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.3.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre><p>依赖包：</p>
<pre><code>&lt;!-- web支持: 1、webmvc; 2、restful; 3、jackjson支持; 4、aop ........ --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- servlet依赖. --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--JSTL（JSP Standard TagLibrary，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，
    是由apache的jakarta小组来维护的。JSTL只能运行在支持JSP1.2和Servlet2.3规范的容器上，
    如tomcat 4.x。在JSP2.0中也是作为标准支持的。不然报异常信息：
    javax.servlet.ServletException:Circular view path [/helloJsp]: 
    would dispatch back to the current handler URL[/helloJsp] again.
    Check your ViewResolver setup!
    (Hint: This may be the resultof an unspecified view, 
    due to default view name generation.)
 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- tomcat的支持.--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>Jdk编译版本：</p>
<pre><code>&lt;build&gt;
      &lt;finalName&gt;spring-boot-jsp&lt;/finalName&gt;
      &lt;plugins&gt;
             &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;configuration&gt;
                          &lt;source&gt;1.7&lt;/source&gt;
                          &lt;target&gt;1.7&lt;/target&gt;
                    &lt;/configuration&gt;
             &lt;/plugin&gt;
      &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><h4 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h4><p>上面说了spring-boot 不推荐JSP，想使用JSP需要配置application.properties。<br>添加src/main/resources/application.properties内容：</p>
<pre><code>#页面默认前缀目录
spring.mvc.view.prefix=/WEB-INF/jsp/
#响应页面默认后缀
spring.mvc.view.suffix=.jsp
#自定义属性，可以在Controller中读取
application.hello=HelloAngel From application
</code></pre><h4 id="编写测试Controller"><a href="#编写测试Controller" class="headerlink" title="编写测试Controller"></a>编写测试Controller</h4><p>编写类：com.kfit.jsp.controller.HelloController：</p>
<pre><code>package com.kfit.jsp.controller;
import java.util.Map;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
/**
 *测试
 * @tearfive(QQ:415896243)
 * @version v.0.1
 */
@Controller
public class HelloController {
    //从 application.properties 中读取配置，如取不到默认值为HelloShanhy
    @Value(&quot;${application.hello:Hello Angel}&quot;)
    private String hello;
    @RequestMapping(&quot;/helloJsp&quot;)
    public StringhelloJsp(Map&lt;String,Object&gt; map){
        System.out.println(&quot;HelloController.helloJsp().hello=&quot;+hello);
        map.put(&quot;hello&quot;,hello);
        return&quot;helloJsp&quot;;
    }
}
</code></pre><h4 id="编写JSP页面"><a href="#编写JSP页面" class="headerlink" title="编写JSP页面"></a>编写JSP页面</h4><p>在 src/main 下面创建 webapp/WEB-INF/jsp 目录用来存放我们的jsp页面：helloJsp.jsp</p>
<pre><code>&lt;%@page language=&quot;java&quot;contentType=&quot;text/html;charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;metahttp-equiv=&quot;Content-Type&quot;content=&quot;text/html; charset=UTF-8&quot;&gt;
        &lt;title&gt;Insert title here&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        helloJsp
        &lt;hr/&gt;
        ${hello}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h4><p>编写App.java启动类：</p>
<pre><code>package com.kfit.jsp;
import org.springframework.boot.SpringApplication;
importorg.springframework.boot.autoconfigure.SpringBootApplication;
importorg.springframework.boot.context.web.SpringBootServletInitializer;
@SpringBootApplication
public class App extends SpringBootServletInitializer {
    //@Override
    //protectedSpringApplicationBuilder configure(SpringApplicationBuilder application){
        //returnapplication.sources(App.class);
    //}
    public static voidmain(String[] args) {
        SpringApplication.run(App.class,args);
    }
}
</code></pre><p>右键Run As  Java Application访问：<a href="http://127.0.0.1:8080/helloJsp" target="_blank" rel="noopener">http://127.0.0.1:8080/helloJsp</a> 可以访问到：</p>
<pre><code>helloJsp
</code></pre><hr>
<pre><code>Hello Angel Fromapplication
</code></pre><p>特别说明：针对el表达式，类似${hello}这个对于servlet的版本是有限制的，2.4版本版本以下是不支持的，是无法进行识别的，请注意。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/tearfive/tearfive.github.io/2015/07/01/Spring Boot_静态资源处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tearfive">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/01/Spring Boot_静态资源处理/" itemprop="url">Spring Boot 静态资源处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-01T22:37:18+08:00">
                2015-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h1><p>Spring Boot 默认的处理方式就已经足够了，默认情况下Spring Boot 使用WebMvcAutoConfiguration中配置的各种属性。</p>
<p>建议使用Spring Boot 默认处理方式，需要自己配置的地方可以通过配置文件修改。</p>
<p>但是如果你想完全控制Spring MVC，你可以在@Configuration注解的配置类上增加@EnableWebMvc，增加该注解以后WebMvcAutoConfiguration中配置就不会生效，你需要自己来配置需要的每一项。这种情况下的配置方法建议参考WebMvcAutoConfiguration类。</p>
<p>本文以下内容针对Spring Boot 默认的处理方式，部分配置通过在application.yml配置文件中设置。</p>
<h1 id="配置资源映射"><a href="#配置资源映射" class="headerlink" title="配置资源映射"></a>配置资源映射</h1><p>Spring Boot默认配置的/..映射到/static（或/public,/resources,/META-INF/resources）,/webjars/..会映射到classpath:/META-INF/resources/webjars/。</p>
<p>注意：上面的/static等目录都是在classpath:下面。</p>
<p>如果你想增加如/mystatic/ **映射到classpath:/mystatic/，你可以让你的配置类继承WebMvcConfigurerAdapter，然后重写如下方法：</p>
<pre><code>@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler(&quot;/mystatic/**&quot;)
        .addResourceLocations(&quot;classpath:/mystatic/&quot;);
}
</code></pre><p>这种方式会在默认的基础上增加/mystatic/ **映射到classpath:/mystatic/，不会影响默认的方式，可以同时使用。</p>
<p>静态资源映射还有一个配置选项，为了简单这里用.properties方式书写：</p>
<pre><code>spring.mvc.static-path-pattern=/** # Path pattern used for static resources.
</code></pre><p>这个配置会影响默认的/.. ,例如修改为/static/..后，只能映射如/static/js/sample.js这样的请求（修改前是/js/sample.js）。这个配置只能写一个值，不像大多数可以配置多个用逗号隔开的。</p>
<h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h1><p>例如有如下目录结构：</p>
<pre><code>└─resources
    │  application.yml
    │
    ├─static
    │  ├─css
    │  │      index.css
    │  │
    │  └─js
    │          index.js
    │
    └─templates
            index.ftl
</code></pre><p>在index.ftl中该如何引用上面的静态资源呢？<br>如下写法：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/index.css&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/index.js&quot;&gt;&lt;/script&gt;
</code></pre><p>注意：默认配置的/ **映射到/static（或/public ，/resources，/META-INF/resources）</p>
<p>当请求/css/index.css的时候，Spring MVC 会在/static/目录下面找到。</p>
<p>如果配置为/static/css/index.css，那么上面配置的几个目录下面都没有/static目录，因此会找不到资源文件！</p>
<p>所以写静态资源位置的时候，不要带上映射的目录名（如/static/，/public/ ，/resources/，/META-INF/resources/）！</p>
<h1 id="使用WebJars"><a href="#使用WebJars" class="headerlink" title="使用WebJars"></a>使用WebJars</h1><p>WebJars：<a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p>
<p>例如使用jquery，添加依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;1.11.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>然后可以如下使用：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/webjars/jquery/1.11.3/jquery.js&quot;&gt;&lt;/script&gt;
</code></pre><p>你可能注意到href中的1.11.3版本号了，如果仅仅这么使用，那么当我们切换版本号的时候还要手动修改href，怪麻烦的，我们可以用如下方式解决。</p>
<p>先在pom.xml中添加依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>增加一个WebJarController：</p>
<pre><code>@Controller
public class WebJarController {
    private final WebJarAssetLocator assetLocator = new WebJarAssetLocator();
    @ResponseBody
    @RequestMapping(&quot;/webjarslocator/{webjar}/**&quot;)
    public ResponseEntity locateWebjarAsset(@PathVariable String webjar, HttpServletRequest request) {
        try {
            String mvcPrefix = &quot;/webjarslocator/&quot; + webjar + &quot;/&quot;;
            String mvcPath = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);
            String fullPath = assetLocator.getFullPath(webjar, mvcPath.substring(mvcPrefix.length()));
            return new ResponseEntity(new ClassPathResource(fullPath), HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);
        }
    }
}
</code></pre><p>然后使用的时候按照如下方式：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/webjarslocator/jquery/jquery.js&quot;&gt;&lt;/script&gt;
</code></pre><p>注意：这里不需要在写版本号了，但是注意写url的时候，只是在原来url基础上去掉了版本号，其他的都不能少！</p>
<h1 id="静态资源版本管理"><a href="#静态资源版本管理" class="headerlink" title="静态资源版本管理"></a>静态资源版本管理</h1><p>Spring MVC 提供了静态资源版本映射的功能。</p>
<p>用途：当我们资源内容发生变化时，由于浏览器缓存，用户本地的静态资源还是旧的资源，为了防止这种情况导致的问题，我们可能会手动在请求url的时候加个版本号或者其他方式。</p>
<p>版本号如：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/sample.js?v=1.0.1&quot;&gt;&lt;/script&gt;
</code></pre><p>Spring MVC 提供的功能可以很容易的帮助我们解决类似问题。</p>
<p>Spring MVC 有两种解决方式。</p>
<p>注意：下面的配置方式针对freemarker模板方式，其他的配置方式可以参考。</p>
<h1 id="资源名-md5-方式"><a href="#资源名-md5-方式" class="headerlink" title="资源名-md5 方式"></a>资源名-md5 方式</h1><p>例如：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/index-2b371326aa93ce4b611853a309b69b29.css&quot;&gt;
</code></pre><p>Spring 会自动读取资源md5，然后添加到index.css的名字后面，因此当资源内容发生变化的时候，文件名发生变化，就会更新本地资源。</p>
<p>配置方式：</p>
<p>在application.properties中做如下配置：</p>
<pre><code>spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
</code></pre><p>这样配置后，所有/ **请求的静态资源都会被处理为上面例子的样子。</p>
<p>到这儿还没完，我们在写资源url的时候还要特殊处理。</p>
<p>首先增加如下配置：</p>
<pre><code>@ControllerAdvice
public class ControllerConfig {
    @Autowired
    ResourceUrlProvider resourceUrlProvider;
    @ModelAttribute(&quot;urls&quot;)
    public ResourceUrlProvider urls() {
        return this.resourceUrlProvider;
    }
}
</code></pre><p>然后在页面写的时候用下面的写法：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;${urls.getForLookupPath(&apos;/css/index.css&apos;)}&quot;&gt;
</code></pre><p>使用urls.getForLookupPath(‘/css/index.css’)来得到处理后的资源名。</p>
<h1 id="版本号-方式"><a href="#版本号-方式" class="headerlink" title="版本号 方式"></a>版本号 方式</h1><p>在application.properties中做如下配置：</p>
<pre><code>spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/**,/v1.0.0/**
spring.resources.chain.strategy.fixed.version=v1.0.0
</code></pre><p>这里配置需要特别注意，将version的值配置在paths中。原因我们在讲Spring MVC 处理逻辑的时候说。</p>
<p>在页面写的时候，写法如下：</p>
<pre><code>script type=&quot;text/javascript&quot; src=&quot;${urls.getForLookupPath(&apos;/js/index.js&apos;)}&quot;&gt;&lt;/script&gt;
</code></pre><p>注意，这里仍然使用了urls.getForLookupPath，urls配置方式见上一种方式。</p>
<p>在请求的实际页面中，会显示为：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/v1.0.0/js/index.js&quot;&gt;&lt;/script&gt;
</code></pre><p>可以看到这里的地址是/v1.0.0/js/index.js。</p>
<h1 id="静态资源版本管理-处理过程"><a href="#静态资源版本管理-处理过程" class="headerlink" title="静态资源版本管理 处理过程"></a>静态资源版本管理 处理过程</h1><p>在Freemarker模板首先会调用urls.getForLookupPath方法，返回一个/v1.0.0/js/index.js或/css/index-2b371326aa93ce4b611853a309b69b29.css。</p>
<p>这时页面上的内容就是处理后的资源地址。</p>
<p>这之后浏览器发起请求。</p>
<p>这里分开说。</p>
<h3 id="第一种md5方式"><a href="#第一种md5方式" class="headerlink" title="第一种md5方式"></a>第一种md5方式</h3><p>请求/css/index-2b371326aa93ce4b611853a309b69b29.css，我们md5配置的paths=/ **，所以Spring MVC 会尝试url中是否包含-，如果包含会去掉后面这部分，然后去映射的目录（如/static/）查找/css/index.css文件，如果能找到就返回。</p>
<h3 id="第二种版本方式"><a href="#第二种版本方式" class="headerlink" title="第二种版本方式"></a>第二种版本方式</h3><p>请求/v1.0.0/js/index.js。</p>
<p>如果我们paths中没有配置/v1.0.0，那么上面这个请求地址就不会按版本方式来处理，因此会找不到上面的资源。</p>
<p>如果配置了/v1.0.0，Spring 就会将/v1.0.0去掉再去找/js/index.js，最终会在/static/下面找到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tearfive</p>
              <p class="site-description motion-element" itemprop="description">记录生活点滴</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tearfive</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
